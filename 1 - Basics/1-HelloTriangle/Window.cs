using OpenTK.Graphics.OpenGL4;
using OpenTK.Windowing.Common;
using OpenTK.Windowing.Desktop;
using OpenTK.Windowing.GraphicsLibraryFramework;

namespace _1_HelloTriangle
{
    /* Суть рисования примитивов очень проста. Нам нужно:
     * 1 -  В памяти видеокарты создать объекты. Буфер в котором храниться массив вершин и шейдер (миниатюрная программа,
     *      которая выполняется на GPU видиокарты и не посредственно вычисляет цвет каждого пиксиля)
     * 2 -  При каждом вызове OnRenderFrame() очищаем буфер экрана, активируем шейдер, отрисовываем, команда на смену буфера экрана.
     * 3 -  Перед закрытием окна очищаем память видеокарты от объектов которые мы в ней создали
     * https://opentk.net/learn/chapter1/2-hello-triangle.html */

    public class Window : GameWindow
    {
        /* Создаем массив с вершинами нашего треугольника. Они указаны в нормализованных координатах устройства (NDC).
         * В NDC (0, 0) - это центр экрана.
         * Отрицательные координаты X перемещаются влево, положительные координаты X перемещаются вправо.
         * Отрицательные координаты Y перемещаются вниз, положительные координаты Y перемещаются вверх.
         * OpenGL поддерживает рендеринг только в 3D, поэтому для создания плоского треугольника координата Z будет сохранена как 0.*/
        private readonly float[] _vertices =
        {
            -0.5f, -0.5f, 0.0f, // Нижняя левая вершина
             0.5f, -0.5f, 0.0f, // Внизу правая вершина
             0.0f, 0.5f, 0.0f   // Верхняя вершина
        };

        /* Это дескрипторы объектов OpenGL. Дескриптор - это целое число, представляющее, где находится объект на
         * видеокарта. Считайте их чем-то вроде указателя; мы ничего не можем сделать с ними напрямую, но мы можем
         * отправлять их функциям OpenGL, которым они нужны.
         * Что это за объекты, будет объяснено в OnLoad. */
        private int _vertexBufferObject;
        private int _vertexArrayObject;

        // Этот класс является оболочкой шейдера, которая помогает нам управлять им.
        // Что такое шейдеры и для чего они используются, объяснено в коде самого класса.
        private Shader _shader;

        public Window(NativeWindowSettings nativeWindowSettings) : base(GameWindowSettings.Default, nativeWindowSettings)
        {
            VSync = VSyncMode.On;
            CursorVisible = true;
        }

        // Теперь мы начинаем инициализировать OpenGL.
        protected override void OnLoad()
        {
            base.OnLoad();
            // Это будет цвет фона после того, как мы его очистим, в нормализованных цветах.
            // Нормализованные цвета отображаются в диапазоне от 0,0 до 1,0, где 0,0 представляет черный цвет, а 1,0 -
            // максимально возможное значение для этого канала.
            // Это темно-зеленый цвет.
            GL.ClearColor(0.2f, 0.3f, 0.3f, 1.0f);

            // Нам нужно отправить наши вершины на видеокарту, чтобы OpenGL мог их использовать.
            // Для этого нам нужно создать так называемый объект буфера вершин (VBO).
            // Они позволяют загружать кучу данных в буфер и отправлять буфер на видеокарту.
            // Это эффективно отправляет все вершины одновременно.

            // Во-первых, нам нужно создать буфер. Эта функция возвращает его дескриптор, но на данный момент он пуст.
            _vertexBufferObject = GL.GenBuffer();

            // Теперь связываем буфер. OpenGL использует одно глобальное состояние, поэтому после его вызова
            // все будущие вызовы, которые изменяют VBO, будут применяться к этому буферу, пока вместо этого не будет привязан другой буфер.
            // Первый аргумент - это перечисление, определяющее, какой тип буфера мы связываем. VBO - это ArrayBuffer.
            // Есть несколько типов буферов, но пока необходим только VBO.
            // Второй аргумент - это дескриптор нашего буфера.
            GL.BindBuffer(BufferTarget.ArrayBuffer, _vertexBufferObject);

            // Наконец, загружаем вершины в буфер.
            // Аргументы:
            // В какой буфер следует отправлять данные.
            // Сколько данных в байтах отправляется. Обычно вы можете установить это значение длины вашего массива, умноженное на sizeof (тип массива).
            // Сами вершины.
            // Как будет использоваться буфер, чтобы OpenGL мог записывать данные в нужное пространство памяти графического процессора.
            // Есть три разных BufferUsageHints для рисования:
            // StaticDraw: этот буфер редко, если вообще когда-либо, не обновляется после первоначальной загрузки.
            // DynamicDraw: этот буфер будет часто меняться после первоначальной загрузки.
            // StreamDraw: этот буфер будет изменяться в каждом кадре.
            // Запись в правильное пространство памяти важна! Как правило, вам нужен только StaticDraw,
            // но убедитесь, что используете правильный вариант для вашего случая использования.
            GL.BufferData(BufferTarget.ArrayBuffer, _vertices.Length * sizeof(float), _vertices, BufferUsageHint.StaticDraw);

            // В буфере, в который мы только что загрузили данные, примечательно то, что он не имеет никакой структуры.
            // Это просто набор чисел с плавающей запятой (на самом деле это просто байты). Драйвер opengl не знает, как следует
            // интерпретировать эти данные и как их следует разделить на вершины. Для этого opengl вводит идею Vertex Array Obejct (VAO),
            // который отслеживает, какие части или какие буферы соответствуют каким данным. В этом примере мы хотим настроить VAO так, чтобы
            // он сообщает opengl, что мы хотим интерпретировать 12 байтов как 3 числа с плавающей запятой и с помощью этого разделить буфер на вершины.
            // Для этого мы генерируем и связываем VAO (что обманчиво похоже на создание и привязку VBO, но они разные!).
            _vertexArrayObject = GL.GenVertexArray();
            GL.BindVertexArray(_vertexArrayObject);

            // Теперь нам нужно настроить, как вершинный шейдер будет интерпретировать данные VBO; вы можете отправить ему почти любой тип данных
            // C (а также несколько типов данных, отличных от C). Хотя это делает их невероятно гибкими, это означает, что мы должны указать,
            // как эти данные будут отображаться во входные переменные шейдера.

            // Для этого используем функцию GL.VertexAttribPointer
            // У этой функции есть две задачи: сообщить opengl о формате данных, а также связать текущий буфер массива с VAO.  Внимание!!! Тут очень важно!!!
            // Это означает, что после этого вызова мы установили этот атрибут для получения данных из текущего буфера массива и интерпретируем их так, как мы указали.
            // Аргументы:
            // Расположение входной переменной в шейдере. строка layout (location = 0) в вершинном шейдере явно устанавливает его в 0.
            // Сколько элементов будет отправлено в переменную. В этом случае на каждую вершину приходится по 3 поплавка.
            // Тип данных набора элементов, в данном случае float.
            // Следует ли преобразовывать данные в нормализованные координаты устройства. В данном случае false, потому что это уже сделано.
            // Шаг; это количество байтов между последним элементом одной вершины и первым элементом следующей. 3 * sizeof (float) в этом случае.
            // Смещение; это количество байтов, которое нужно пропустить, чтобы найти первый элемент первой вершины. 0 на данный момент.
            // Шаг и смещение на данный момент просто приукрашены, но когда мы перейдем к координатам текстуры, они будут показаны более подробно.
            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, false, 3 * sizeof(float), 0);

            // Включаем переменную 0 в шейдере.
            GL.EnableVertexAttribArray(0);

            // У нас есть вершины, но как именно преобразовать их в пиксели для окончательного изображения?
            // Современный OpenGL делает этот конвейер очень свободным, давая нам большую свободу в том, как вершины превращаются в пиксели.
            // Недостаток в том, что для этого нам действительно нужны еще две программы! Это так называемые шейдеры.
            // Шейдеры - это крошечные программы, которые живут на графическом процессоре. OpenGL использует их для обработки конвейера от вершины к пикселю.
            // Ознакомьтесь с классом Shader, чтобы увидеть, как мы создаем шейдеры, а также для более подробного объяснения того, как работают шейдеры.
            // shader.vert и shader.frag содержат фактический код шейдера.
            _shader = new Shader("Shaders/shader.vert", "Shaders/shader.frag");

            // Теперь включаем шейдер.
            // Как и VBO, это глобально, поэтому каждая функция, использующая шейдер, будет изменять его, пока вместо этого не будет привязана новая.
            _shader.Use();

            // Настройка завершена! Теперь переходим к функции OnRenderFrame, чтобы окончательно нарисовать треугольник.
        }

        // Теперь, когда инициализация завершена, давайте создадим наш цикл рендеринга.
        protected override void OnRenderFrame(FrameEventArgs e)
        {
            base.OnRenderFrame(e);

            // Это очищает изображение, используя то, что вы ранее установили как GL.ClearColor.
            // OpenGL предоставляет несколько различных типов данных, которые могут быть отображены.
            // Вы можете очистить несколько буферов, используя несколько битовых флагов.
            // Однако мы изменяем только цвет, поэтому ColorBufferBit - это все, что нам нужно очистить.
            GL.Clear(ClearBufferMask.ColorBufferBit);

            // Чтобы нарисовать объект в OpenGL, это обычно так же просто, как привязка вашего шейдера,
            // установка униформы шейдера (здесь не делается, будет показано в следующих уроках)
            // привязываем VAO,
            // а затем вызываем функцию OpenGL для рендеринга.

            // Привязываем шейдер
            _shader.Use();

            // Связываем VAO
            GL.BindVertexArray(_vertexArrayObject);

            // А затем вызываем нашу функцию рисования.
            // В этом руководстве мы будем использовать GL.DrawArrays, который представляет собой очень простую функцию отрисовки.
            // Аргументы:
            // примитивный тип; Какой геометрический примитив представляют собой вершины.
            // OpenGL раньше поддерживал множество различных примитивных типов, но почти все из них все еще поддерживаются
            // это некий вариант треугольника. Поскольку нам нужен только один треугольник, мы используем Triangles.
            // Начальный индекс; это только начало данных, которые вы хотите нарисовать. 0 здесь.
            // Сколько вершин вы хотите нарисовать. 3 для треугольника.

            // GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line); //Способ отображения    //  PolygonMode.Fill - Отрисовывает примитив заполненным.

            GL.DrawArrays(PrimitiveType.TriangleFan, 0, 3);


            // Окна OpenTK известны как "двойная буферизация". По сути, окно управляет двумя буферами.
            // Один рендерим, а другой отображается в окне.
            // Это позволяет избежать разрывов экрана, визуального артефакта, который может произойти, если буфер изменяется во время отображения.
            // После рисования вызовите эту функцию, чтобы поменять местами буферы. Если вы этого не сделаете, он не будет отображать то, что вы отрендерили.
            SwapBuffers();

            // И это все, что вам нужно сделать для рендеринга! Теперь вы должны увидеть желтый треугольник на черном экране.
        }

        protected override void OnUpdateFrame(FrameEventArgs e)
        {
            base.OnUpdateFrame(e);

            var input = KeyboardState;

            if (input.IsKeyDown(Keys.Escape))
            {
                Close();
            }
        }

        protected override void OnResize(ResizeEventArgs e)
        {
            base.OnResize(e);

            // Когда размер окна изменяется, мы должны вызвать GL.Viewport, чтобы изменить размер окна просмотра OpenGL в соответствии с новым размером.
            // Если мы этого не сделаем, NDC перестанет быть правильным.
            GL.Viewport(0, 0, Size.X, Size.Y);
        }

        // Теперь для очистки.
        // Обычно вы не должны очищать ресурсы opengl при выходе из приложения
        // поскольку это обрабатывается драйвером и операционной системой при выходе из приложения.
        //
        // Есть причины для удаления ресурсов opengl, но выход из приложения не входит в их число.
        // Здесь указано, как выполняется очистка ресурсов в opengl, но
        // не следует делать при выходе из приложения.
        //
        // В местах, где целесообразна очистка, следует удалить текстуры, которые
        // больше не используется по какой-либо причине (например, загружается новая сцена, в которой не используется текстура).
        // Это освободит видеопамять (VRAM), которую можно использовать для новых текстур.
        //
        // В следующих главах этого кода не будет.
        protected override void OnUnload()
        {
            base.OnUnload();

            // Отключаем все ресурсы, привязывая цели к 0 / null.
            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
            GL.BindVertexArray(0);
            GL.UseProgram(0);

            // Удаляем все ресурсы.
            GL.DeleteBuffer(_vertexBufferObject);
            GL.DeleteVertexArray(_vertexArrayObject);

            GL.DeleteProgram(_shader.Handle);
        }
    }
}